

#### HashMap ####
HashMap 底层源码是： 数组 + 链表 + 红黑树。 当链表长度大于等于8并且数组大小超过64时，链表转化成红黑树。当红黑树大小小于等于6时，红黑树转化成链表。



在迭代过程中，如果HashMap的结构被修改，会快速执行失败。



HashMap 新增：

1.空数组有无进行初始化，没有则进行初始化。
2.通过key的hash找到相同的key值时，转6，否则转3
3.是否hash冲突。冲突则两种方法。链表或者红黑树
4.如果是链表，则循环，追加到链表尾
5.如果是红黑树，调用红黑树新增的方法
通过 2 4 5 找到对应的追加的微信，再根据onlyIfAbsent 判断是否覆盖
判断是够需要扩容

2 4 5 实际都是找出要新增节点的位置。 后面在决定是够覆盖。

扩容的条件 ： 数组大小 > 数组容量 * 0.75

0.75 是一个影响因子。均衡了时间和空间。 如果太大，好处是会减少空间的消耗（扩容减少，数组大大小增长速度变慢），但是增加了查找的成本（因为hash冲突增加，链表或者红黑树边长）

HashMap查找：

根据key计算hash值，找到在索引的位置，通过equals判断key值相等，相等直接返回，否则下一步
判断当前节点有无next，有则判断是链表还是红黑树
分别走链表或者红黑树的查找方法


HashMap 是对key进行hash求值，得出索引位置进行存储.TreeMap是根据对key进行比较，然后利用红黑树左节点小，右节点大的性质排序存储。

#### TreeMap ####
TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。

不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景

TreeMap如何进行比较

比较器，如果外部有传进来 Comparator 比较器，首先用外部的

如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法

#### LinkListHashMap ####
HashMap 是无序的，TreeMap 可以按照 key 进行排序，LinkListHashMap可以维护插入的顺序。

本质是增加了一个单向链表结构。 像是LinkList 和 HashMap的结合体。

LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。
