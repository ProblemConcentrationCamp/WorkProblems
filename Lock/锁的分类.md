

#### 自旋锁 ####
如果持有锁的线程能在短时间内释放锁资源，那么等待竞争锁的线程就不必切换到阻塞的状态，只需要等一等（自旋：循环等待）,
等到持有锁的线程释放资源即可获取。避免了线程切换状态带来的消耗。

优点： 在锁竞争不激烈，且占用时间不多的情况下，能较好的提升性能。
缺点： 如果锁竞争激烈，或占用时间过长，那么自旋等待的线程就会一直在做无用功，此时自旋等待的消耗大于切换线程状态的消耗。

#### 悲观锁、乐观锁 ####
线程要不要锁住共享资源?
* 锁住: 悲观锁。 适合多写少读的场景。因为多线程操作下，共享资源需要锁住，否则会出现数据错误。
* 不锁住: 乐观锁。每次在拿数据的时候，认为数据不会被修改，所以不上锁。 适合多读少写的场景。 但是在更新的
的时候会判断一下在此期间数据有没有被修改。可以使用版本号机制或CAS算法实现。


#### 公平锁、非公平锁 ####
多个线程竞争锁时要不要排队?
* 排队：公平锁
* 先尝试插队，失败再排队：非公平锁



#### 可重入锁、不可重入锁 ####
一个线程能否重复获取同一把锁?
* 能：可重入锁
* 不能：不可重入锁


#### 共享锁、排它锁 ####
多个线程能否共享同一把锁?
* 能：共享锁。事务T对数据A加上共享锁后，其他事务只能增加共享锁。拥有共享锁的事务可以对数据进行读，但是不能修改。
* 不能：排它锁。事务T对数据A加上排它锁后，其他事务不能加任何锁。获取排它锁的事务能读写数据。


#### 偏向锁、轻量锁、重量锁 ####
多个线程竞争同步资源时流程细节有误区别？
* 偏向第一个访问锁的线程，在没有竞争的情况下，该线程不需要进行同步，提高性能。否则，在有
竞争的情况下，会主动释放锁。 - 偏向锁
* 多个线程竞争同步资源，失败的等待自旋释放锁 - 轻量锁
* 多个线程竞争同步资源，失败的等待唤醒。 - 重量锁


