
##### 事务

事务是一组操作构成的可靠的独立的工作单元，具备ACID的特性。要么都不完成，要么都完成。

##### 事务的四大原则 ACID

* A：原子性。操作要么都完成，要么都不完成。

* C：一致性。事务完成后，结果是完整的。

* I：隔离性。规定了两个以上的事务操作统一数据时的隔离机制。

* D：持久性。在事务被提交后，数据才会被持久化的存储。

#### 事务的隔离级别

隔离级别规定了两个以上的事务操作统一数据时的隔离机制。

并发的事务，会导致数据有以下的情况：
* 脏读。事务A读取了事务B还未commit的数据。

* 不可重复读。同一个事务内，两次相同的查询返回的结果不一致。例如： 事务B在执行期间重复读取某个表的数据，这时事务A修改了同一张表的数据，此时还未
结束的事务B再读取时，发现读取的数据和之前的数据不一致。

* 幻读。 同样的条件，第一次和第二次读取的记录不一致。 例如： 事务A第一次读取某个表数据，期间事务B对同一表插入了数据，之后事务A再以
相同条件第二次查询数据，发现多了数据，两次查询记录不一致。

隔离级别： 

* DEFAULT: 默认级别，数据库使用什么隔离机制，那么事务同样采用什么级别。

* READ_UNCOMMITED: 表示一个事务可以读取另一个事务未commited的数据。会导致脏读和不可重复读。

* READ_COMMITED: 表示一个事务只能读取另一个事务已commited的数据。 可以防止脏读。

* REPEATABLE_READ: 可重复读。表示事务A在重复读取数据时，即使另一个事务修改了数据并commited，
但事务A之后再次重复读取的数据都是相同的。可防止脏读和重复读，不可防止幻读。

* SERIALZABLED: 序列化读取。所有的事务依次执行，不允许并发执行。可防止脏读，重复读，幻读。
但会严重影响性能。


#### 事务的传播

定义 同时存在多个事务（事务方法嵌套）时，事务是如何传播的。

https://segmentfault.com/a/1190000013341344

假设方法A（有事务）调用方法B（有事务）。

* PROPAGATION_REQUIRED(Default)：事务是必须的。如果当前没有事务，则新建。如果已经存在，则加入，不需要新建。
 方法B传播属性定义为REQUIRED（必须）时，方法A已经创建事务，则方法B不需要再创建。

* PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，以非事务方式执行。 方法A没有创建事务，那么调用的方法B也不需要在事务中。

* PROPAGATION_MANDATROY：使用当前事务，没有则抛出异常。方法B必须在一个事务中。

* PROPAGATION_REQUIRED_NEW：新建事务。如果当前事务已存在，则先挂起。

* PROPAGATION_NO_SUPPORTS：不支持事务。以非事务的方式执行，如果存在当前事务则挂起。

* PROPAGATION_NEVER：绝不。以非事务的方式执行，如果存在当前事务则抛出异常。

* PROPAGATION_NTSTED：嵌套事务。如果当前存在事务，则在嵌套事务执行。


